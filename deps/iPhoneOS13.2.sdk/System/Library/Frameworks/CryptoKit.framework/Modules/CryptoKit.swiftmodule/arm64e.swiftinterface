// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.1.1 (swiftlang-1100.2.274.2 clang-1100.2.32.1)
// swift-module-flags: -target arm64e-apple-ios13.2 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name CryptoKit
import Foundation
import LocalAuthentication
import Security.SecAccessControl
import Security
import Swift
extension Curve25519.Signing.PublicKey {
  public func isValidSignature<S, D>(_ signature: S, for data: D) -> Swift.Bool where S : Foundation.DataProtocol, D : Foundation.DataProtocol
}
extension Curve25519.Signing.PrivateKey {
  public func signature<D>(for data: D) throws -> Foundation.Data where D : Foundation.DataProtocol
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum Curve25519 {
}
extension P256 {
  public enum Signing {
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public init<Bytes>(compactRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var compactRepresentation: Foundation.Data? {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
    public struct PrivateKey {
      public init(compactRepresentable: Swift.Bool = true)
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(rawRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var publicKey: CryptoKit.P256.Signing.PublicKey {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
  }
}
extension P256 {
  public enum KeyAgreement {
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public init<Bytes>(compactRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var compactRepresentation: Foundation.Data? {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
    public struct PrivateKey {
      public init(compactRepresentable: Swift.Bool = true)
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(rawRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var publicKey: CryptoKit.P256.KeyAgreement.PublicKey {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
  }
}
extension P384 {
  public enum Signing {
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public init<Bytes>(compactRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var compactRepresentation: Foundation.Data? {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
    public struct PrivateKey {
      public init(compactRepresentable: Swift.Bool = true)
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(rawRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var publicKey: CryptoKit.P384.Signing.PublicKey {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
  }
}
extension P384 {
  public enum KeyAgreement {
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public init<Bytes>(compactRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var compactRepresentation: Foundation.Data? {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
    public struct PrivateKey {
      public init(compactRepresentable: Swift.Bool = true)
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(rawRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var publicKey: CryptoKit.P384.KeyAgreement.PublicKey {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
  }
}
extension P521 {
  public enum Signing {
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public init<Bytes>(compactRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var compactRepresentation: Foundation.Data? {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
    public struct PrivateKey {
      public init(compactRepresentable: Swift.Bool = true)
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(rawRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var publicKey: CryptoKit.P521.Signing.PublicKey {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
  }
}
extension P521 {
  public enum KeyAgreement {
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public init<Bytes>(compactRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var compactRepresentation: Foundation.Data? {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
    public struct PrivateKey {
      public init(compactRepresentable: Swift.Bool = true)
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(rawRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var publicKey: CryptoKit.P521.KeyAgreement.PublicKey {
        get
      }
      public var rawRepresentation: Foundation.Data {
        get
      }
      public var x963Representation: Foundation.Data {
        get
      }
    }
  }
}
extension P256.KeyAgreement.PrivateKey {
  public func sharedSecretFromKeyAgreement(with publicKeyShare: CryptoKit.P256.KeyAgreement.PublicKey) throws -> CryptoKit.SharedSecret
}
extension P384.KeyAgreement.PrivateKey {
  public func sharedSecretFromKeyAgreement(with publicKeyShare: CryptoKit.P384.KeyAgreement.PublicKey) throws -> CryptoKit.SharedSecret
}
extension P521.KeyAgreement.PrivateKey {
  public func sharedSecretFromKeyAgreement(with publicKeyShare: CryptoKit.P521.KeyAgreement.PublicKey) throws -> CryptoKit.SharedSecret
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct HMAC<H> where H : CryptoKit.HashFunction {
  public typealias Key = CryptoKit.SymmetricKey
  public typealias MAC = CryptoKit.HashedAuthenticationCode<H>
  public static func isValidAuthenticationCode(_ mac: CryptoKit.HMAC<H>.MAC, authenticating bufferPointer: Swift.UnsafeRawBufferPointer, using key: CryptoKit.SymmetricKey) -> Swift.Bool
  public init(key: CryptoKit.SymmetricKey)
  public static func authenticationCode<D>(for data: D, using key: CryptoKit.SymmetricKey) -> CryptoKit.HMAC<H>.MAC where D : Foundation.DataProtocol
  public static func isValidAuthenticationCode<D>(_ authenticationCode: CryptoKit.HMAC<H>.MAC, authenticating authenticatedData: D, using key: CryptoKit.SymmetricKey) -> Swift.Bool where D : Foundation.DataProtocol
  @available(iOS 13.2, OSX 10.15, watchOS 6.1, tvOS 13.2, *)
  public static func isValidAuthenticationCode<C, D>(_ authenticationCode: C, authenticating authenticatedData: D, using key: CryptoKit.SymmetricKey) -> Swift.Bool where C : Foundation.ContiguousBytes, D : Foundation.DataProtocol
  mutating public func update<D>(data: D) where D : Foundation.DataProtocol
  public func finalize() -> CryptoKit.HMAC<H>.MAC
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct HashedAuthenticationCode<H> : CryptoKit.MessageAuthenticationCode where H : CryptoKit.HashFunction {
  public var byteCount: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
  public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
  public typealias Element = Swift.UInt8
  public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@usableFromInline
internal struct SecureBytes {
  @usableFromInline
  internal var backing: CryptoKit.SecureBytes.Backing!
  @inlinable internal init() {
        self = .init(count: 0)
    }
  @usableFromInline
  internal init(count: Swift.Int)
  @usableFromInline
  internal init(unsafeUninitializedCapacity: Swift.Int, initializingWith callback: (inout Swift.UnsafeMutableRawBufferPointer, inout Swift.Int) throws -> Swift.Void) rethrows
}
extension SecureBytes {
  @inlinable mutating internal func append<C>(_ data: C) where C : Swift.Collection, C.Element == Swift.UInt8 {
        let requiredCapacity = self.count + data.count
        if !isKnownUniquelyReferenced(&self.backing) || requiredCapacity > self.backing.capacity {
            let newBacking = Backing.create(capacity: requiredCapacity)
            newBacking._appendBytes(self.backing, inRange: 0..<self.count)
            self.backing = newBacking
        }
        self.backing._appendBytes(data)
    }
  @usableFromInline
  mutating internal func reserveCapacity(_ n: Swift.Int)
}
extension SecureBytes : Swift.Equatable {
  public static func == (lhs: CryptoKit.SecureBytes, rhs: CryptoKit.SecureBytes) -> Swift.Bool
}
extension SecureBytes : Swift.Collection {
  @usableFromInline
  internal struct Index {
    @usableFromInline
    internal var offset: Swift.Int
    @usableFromInline
    internal init(offset: Swift.Int)
  }
  @inlinable internal var startIndex: CryptoKit.SecureBytes.Index {
    get {
        return Index(offset: 0)
    }
  }
  @inlinable internal var endIndex: CryptoKit.SecureBytes.Index {
    get {
        return Index(offset: self.count)
    }
  }
  @inlinable internal var count: Swift.Int {
    get {
        return self.backing.count
    }
  }
  @inlinable internal subscript(index: CryptoKit.SecureBytes.Index) -> Swift.UInt8 {
    get {
            return self.backing[offset: index.offset]
        }
    set {
            self.backing[offset: index.offset] = newValue
        }
  }
  @inlinable internal func index(after index: CryptoKit.SecureBytes.Index) -> CryptoKit.SecureBytes.Index {
        return index.advanced(by: 1)
    }
  @usableFromInline
  internal typealias Element = Swift.UInt8
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<CryptoKit.SecureBytes>
  @usableFromInline
  internal typealias SubSequence = Swift.Slice<CryptoKit.SecureBytes>
  @usableFromInline
  internal typealias Indices = Swift.Range<CryptoKit.SecureBytes.Index>
}
extension SecureBytes : Swift.BidirectionalCollection {
  @inlinable internal func index(before index: CryptoKit.SecureBytes.Index) -> CryptoKit.SecureBytes.Index {
        return index.advanced(by: -1)
    }
}
extension SecureBytes : Swift.RandomAccessCollection {
}
extension SecureBytes : Swift.MutableCollection {
}
extension SecureBytes : Swift.RangeReplaceableCollection {
  @inlinable mutating internal func replaceSubrange<C>(_ subrange: Swift.Range<CryptoKit.SecureBytes.Index>, with newElements: C) where C : Swift.Collection, C.Element == Swift.UInt8 {
        let requiredCapacity = self.backing.count - subrange.count + newElements.count

        if !isKnownUniquelyReferenced(&self.backing) || requiredCapacity > self.backing.capacity {
            // We have to allocate anyway, so let's use a nice straightforward copy.
            let newBacking = Backing.create(capacity: requiredCapacity)

            let lowerSlice = 0..<subrange.lowerBound.offset
            let upperSlice = subrange.upperBound.offset..<self.count

            newBacking._appendBytes(self.backing, inRange: lowerSlice)
            newBacking._appendBytes(newElements)
            newBacking._appendBytes(self.backing, inRange: upperSlice)

            self.backing = newBacking
            return
        } else {
            // We have room, and a unique pointer. Ask the backing storage to shuffle around.
            let offsetRange = subrange.lowerBound.offset..<subrange.upperBound.offset
            self.backing.replaceSubrangeFittingWithinCapacity(offsetRange, with: newElements)
        }
    }
}
extension SecureBytes : Foundation.ContiguousBytes {
  @inlinable internal func withUnsafeBytes<T>(_ body: (Swift.UnsafeRawBufferPointer) throws -> T) rethrows -> T {
        return try self.backing.withUnsafeBytes(body)
    }
  @inlinable mutating internal func withUnsafeMutableBytes<T>(_ body: (Swift.UnsafeMutableRawBufferPointer) throws -> T) rethrows -> T {
        if !isKnownUniquelyReferenced(&self.backing) {
            self.backing = Backing.create(copying: self.backing)
        }

        return try self.backing.withUnsafeMutableBytes(body)
    }
}
extension SecureBytes : Foundation.DataProtocol {
  @inlinable internal var regions: Swift.CollectionOfOne<CryptoKit.SecureBytes> {
    get {
        return CollectionOfOne(self)
    }
  }
  @usableFromInline
  internal typealias Regions = Swift.CollectionOfOne<CryptoKit.SecureBytes>
}
extension SecureBytes : Foundation.MutableDataProtocol {
}
extension SecureBytes.Index : Swift.Hashable {
  @usableFromInline
  internal var hashValue: Swift.Int {
    @usableFromInline
    get
  }
  @usableFromInline
  internal func hash(into hasher: inout Swift.Hasher)
}
extension SecureBytes.Index : Swift.Comparable {
  @usableFromInline
  internal static func < (lhs: CryptoKit.SecureBytes.Index, rhs: CryptoKit.SecureBytes.Index) -> Swift.Bool
}
extension SecureBytes.Index : Swift.Strideable {
  @usableFromInline
  internal func advanced(by n: Swift.Int) -> CryptoKit.SecureBytes.Index
  @usableFromInline
  internal func distance(to other: CryptoKit.SecureBytes.Index) -> Swift.Int
  @usableFromInline
  internal typealias Stride = Swift.Int
}
extension SecureBytes {
  @usableFromInline
  internal struct BackingHeader {
    @usableFromInline
    internal var count: Swift.Int
    @usableFromInline
    internal var capacity: Swift.Int
  }
  @usableFromInline
  internal class Backing : Swift.ManagedBuffer<CryptoKit.SecureBytes.BackingHeader, Swift.UInt8> {
    @usableFromInline
    internal class func create(capacity: Swift.Int) -> CryptoKit.SecureBytes.Backing
    @usableFromInline
    internal class func create(copying original: CryptoKit.SecureBytes.Backing) -> CryptoKit.SecureBytes.Backing
    @inlinable internal class func create<D>(bytes: D) -> CryptoKit.SecureBytes.Backing where D : Foundation.ContiguousBytes {
            return bytes.withUnsafeBytes { bytesPtr in
                let backing = Backing.create(capacity: bytesPtr.count)
                backing._withVeryUnsafeMutableBytes { targetPtr in
                    targetPtr.copyMemory(from: bytesPtr)
                }
                backing.count = bytesPtr.count
                precondition(backing.count <= backing.capacity)
                return backing
            }
        }
    @usableFromInline
    internal class func create(randomBytes: Swift.Int) -> CryptoKit.SecureBytes.Backing
    @objc deinit
    @usableFromInline
    internal var count: Swift.Int {
      get
      set
    }
    @usableFromInline
    internal subscript(offset offset: Swift.Int) -> Swift.UInt8 {
      get
      set
    }
  }
}
extension SecureBytes.Backing {
  @inlinable internal func replaceSubrangeFittingWithinCapacity<C>(_ subrange: Swift.Range<Swift.Int>, with newElements: C) where C : Swift.Collection, C.Element == Swift.UInt8 {
        // This function is called when have a unique reference to the backing storage, and we have enough room to store these bytes without
        // any problem. We have one pre-existing buffer made up of 4 regions: a prefix set of bytes that are
        // before the range "subrange", a range of bytes to be replaced (R1), a suffix set of bytes that are after
        // the range "subrange" but within the valid count, and then a region of uninitialized memory. We also have
        // a new set of bytes, R2, that may be larger or smaller than R1, and could indeed be empty!
        //
        // ┌────────────────────────┬──────────────────┬──────────────────┬───────────────┐
        // │         Prefix         │        R1        │      Suffix      │ Uninitialized │
        // └────────────────────────┴──────────────────┴──────────────────┴───────────────┘
        //
        //                ┌─────────────────────────────────────┐
        //                │                  R2                 │
        //                └─────────────────────────────────────┘
        //
        // The minimal number of steps we can take in the general case is two steps. We can't just copy R2 into the space
        // for R1 and then move the suffix, as if R2 is larger than R1 we'll have thrown some suffix bytes away. So we have
        // to move suffix first. What we do is take the bytes in suffix, and move them (via memmove). We can then copy
        // R2 in, and feel confident that the space in memory is right.
        precondition(self.count - subrange.count + newElements.count <= self.capacity, "Insufficient capacity")

        let moveDistance = newElements.count - subrange.count
        let suffixRange = subrange.upperBound..<self.count
        self._moveBytes(range: suffixRange, by: moveDistance)
        self._copyBytes(newElements, at: subrange.lowerBound)
        self.count += newElements.count - subrange.count
    }
  @inlinable internal func _appendBytes<C>(_ bytes: C) where C : Swift.Collection, C.Element == Swift.UInt8 {
        let byteCount = bytes.count

        precondition(self.capacity - self.count - byteCount >= 0, "Insufficient space for byte copying, must have reallocated!")

        let lowerOffset = self.count
        self._withVeryUnsafeMutableBytes { bytesPtr in
            let innerPtrSlice = UnsafeMutableRawBufferPointer(rebasing: bytesPtr[lowerOffset...])
            innerPtrSlice.copyBytes(from: bytes)
        }
        self.count += byteCount
    }
  @inlinable internal func _appendBytes(_ backing: CryptoKit.SecureBytes.Backing, inRange range: Swift.Range<Swift.Int>) {
        precondition(range.lowerBound >= 0)
        precondition(range.upperBound <= backing.capacity)
        precondition(self.capacity - self.count - range.count >= 0, "Insufficient space for byte copying, must have reallocated!")

        backing.withUnsafeBytes { backingPtr in
            let ptrSlice = UnsafeRawBufferPointer(rebasing: backingPtr[range])

            let lowerOffset = self.count
            self._withVeryUnsafeMutableBytes { bytesPtr in
                let innerPtrSlice = UnsafeMutableRawBufferPointer(rebasing: bytesPtr[lowerOffset...])
                innerPtrSlice.copyMemory(from: ptrSlice)
            }
            self.count += ptrSlice.count
        }
    }
  @usableFromInline
  internal func _moveBytes(range: Swift.Range<Swift.Int>, by delta: Swift.Int)
  @inlinable internal func _copyBytes<C>(_ bytes: C, at offset: Swift.Int) where C : Swift.Collection, C.Element == Swift.UInt8 {
        precondition(offset >= 0)
        precondition(offset + bytes.count <= self.capacity)

        let byteRange = offset..<(offset + bytes.count)

        self._withVeryUnsafeMutableBytes { backingPtr in
            let dest = UnsafeMutableRawBufferPointer(rebasing: backingPtr[byteRange])
            dest.copyBytes(from: bytes)
        }
    }
}
extension SecureBytes.Backing : Foundation.ContiguousBytes {
  @inlinable internal func withUnsafeBytes<T>(_ body: (Swift.UnsafeRawBufferPointer) throws -> T) rethrows -> T {
        let count = self.count

        return try self.withUnsafeMutablePointerToElements { elementsPtr in
            return try body(UnsafeRawBufferPointer(start: elementsPtr, count: count))
        }
    }
  @inlinable internal func withUnsafeMutableBytes<T>(_ body: (Swift.UnsafeMutableRawBufferPointer) throws -> T) rethrows -> T {
        let count = self.count

        return try self.withUnsafeMutablePointerToElements { elementsPtr in
            return try body(UnsafeMutableRawBufferPointer(start: elementsPtr, count: count))
        }
    }
  @inlinable internal func _withVeryUnsafeMutableBytes<T>(_ body: (Swift.UnsafeMutableRawBufferPointer) throws -> T) rethrows -> T {
        let capacity = self.capacity

        return try self.withUnsafeMutablePointerToElements { elementsPtr in
            return try body(UnsafeMutableRawBufferPointer(start: elementsPtr, count: capacity))
        }
    }
}
extension UInt32 {
  @usableFromInline
  internal func nextPowerOf2ClampedToMax() -> Swift.UInt32
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum P256 {
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum P384 {
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum P521 {
}
extension HMAC {
  @usableFromInline
  internal static func isValidAuthenticationCode<D>(_ authenticationCode: Foundation.ContiguousBytes, authenticating authenticatedData: D, using key: CryptoKit.SymmetricKey) -> Swift.Bool where D : Foundation.DataProtocol
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public protocol Digest : Foundation.ContiguousBytes, Swift.CustomStringConvertible, Swift.Hashable, Swift.Sequence where Self.Element == Swift.UInt8 {
  static var byteCount: Swift.Int { get }
}
extension Digest {
  public func makeIterator() -> Swift.Array<Swift.UInt8>.Iterator
}
extension Digest {
  public static func == (lhs: Self, rhs: Self) -> Swift.Bool
  public static func == <D>(lhs: Self, rhs: D) -> Swift.Bool where D : Foundation.DataProtocol
  public var description: Swift.String {
    get
  }
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SHA256Digest {
  public static var byteCount: Swift.Int {
    get
  }
  public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
  public var description: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public typealias Element = Swift.UInt8
  public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SHA384Digest {
  public static var byteCount: Swift.Int {
    get
  }
  public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
  public var description: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public typealias Element = Swift.UInt8
  public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SHA512Digest {
  public static var byteCount: Swift.Int {
    get
  }
  public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
  public var description: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public typealias Element = Swift.UInt8
  public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
  public var hashValue: Swift.Int {
    get
  }
}
extension Insecure {
  @available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
  public struct SHA1Digest {
    public static var byteCount: Swift.Int {
      get
    }
    public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public typealias Element = Swift.UInt8
    public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Insecure {
  @available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
  public struct MD5Digest {
    public static var byteCount: Swift.Int {
      get
    }
    public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public typealias Element = Swift.UInt8
    public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension SecureEnclave.P256.Signing.PrivateKey {
  public func signature<D>(for digest: D) throws -> CryptoKit.P256.Signing.ECDSASignature where D : CryptoKit.Digest
}
extension SecureEnclave.P256.Signing.PrivateKey {
  public func signature<D>(for data: D) throws -> CryptoKit.P256.Signing.ECDSASignature where D : Foundation.DataProtocol
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum SecureEnclave {
}
extension SecureEnclave {
  public static var isAvailable: Swift.Bool {
    get
  }
  public enum P256 {
    public enum Signing {
      public struct PrivateKey {
        public let publicKey: CryptoKit.P256.Signing.PublicKey
        public let dataRepresentation: Foundation.Data
        @available(iOS 13.0, OSX 10.15, *)
        public init(dataRepresentation: Foundation.Data, authenticationContext: LocalAuthentication.LAContext? = nil) throws
        @available(iOS 13.0, OSX 10.15, *)
        public init(compactRepresentable: Swift.Bool = true, accessControl: Security.SecAccessControl = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly, [], nil)!, authenticationContext: LocalAuthentication.LAContext? = nil) throws
      }
    }
    public enum KeyAgreement {
      public struct PrivateKey {
        public let publicKey: CryptoKit.P256.KeyAgreement.PublicKey
        public let dataRepresentation: Foundation.Data
        @available(iOS 13.0, OSX 10.15, *)
        public init(dataRepresentation: Foundation.Data, authenticationContext: LocalAuthentication.LAContext? = nil) throws
        @available(iOS 13.0, OSX 10.15, *)
        public init(compactRepresentable: Swift.Bool = true, accessControl: Security.SecAccessControl = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly, [], nil)!, authenticationContext: LocalAuthentication.LAContext? = nil) throws
      }
    }
  }
}
extension SecureEnclave.P256.KeyAgreement.PrivateKey {
  public func sharedSecretFromKeyAgreement(with publicKeyShare: CryptoKit.P256.KeyAgreement.PublicKey) throws -> CryptoKit.SharedSecret
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SHA256 {
  public static var blockByteCount: Swift.Int
  public typealias Digest = CryptoKit.SHA256Digest
  public static var byteCount: Swift.Int
  public init()
  mutating public func update(bufferPointer: Swift.UnsafeRawBufferPointer)
  public func finalize() -> CryptoKit.SHA256.Digest
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SHA384 {
  public static var blockByteCount: Swift.Int
  public typealias Digest = CryptoKit.SHA384Digest
  public static var byteCount: Swift.Int
  public init()
  mutating public func update(bufferPointer: Swift.UnsafeRawBufferPointer)
  public func finalize() -> CryptoKit.SHA384.Digest
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SHA512 {
  public static var blockByteCount: Swift.Int
  public typealias Digest = CryptoKit.SHA512Digest
  public static var byteCount: Swift.Int
  public init()
  mutating public func update(bufferPointer: Swift.UnsafeRawBufferPointer)
  public func finalize() -> CryptoKit.SHA512.Digest
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum Insecure {
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum ChaChaPoly {
  public static func seal<Plaintext, AuthenticatedData>(_ message: Plaintext, using key: CryptoKit.SymmetricKey, nonce: CryptoKit.ChaChaPoly.Nonce? = nil, authenticating authenticatedData: AuthenticatedData) throws -> CryptoKit.ChaChaPoly.SealedBox where Plaintext : Foundation.DataProtocol, AuthenticatedData : Foundation.DataProtocol
  public static func seal<Plaintext>(_ message: Plaintext, using key: CryptoKit.SymmetricKey, nonce: CryptoKit.ChaChaPoly.Nonce? = nil) throws -> CryptoKit.ChaChaPoly.SealedBox where Plaintext : Foundation.DataProtocol
  public static func open<AuthenticatedData>(_ sealedBox: CryptoKit.ChaChaPoly.SealedBox, using key: CryptoKit.SymmetricKey, authenticating authenticatedData: AuthenticatedData) throws -> Foundation.Data where AuthenticatedData : Foundation.DataProtocol
  public static func open(_ sealedBox: CryptoKit.ChaChaPoly.SealedBox, using key: CryptoKit.SymmetricKey) throws -> Foundation.Data
}
extension ChaChaPoly {
  @available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
  @frozen public struct SealedBox {
    public let combined: Foundation.Data
    public var tag: Foundation.Data {
      get
    }
    public var ciphertext: Foundation.Data {
      get
    }
    public var nonce: CryptoKit.ChaChaPoly.Nonce {
      get
    }
    @inlinable public init<D>(combined: D) throws where D : Foundation.DataProtocol {
            // ChachaPoly nonce (12 bytes) + ChachaPoly tag (16 bytes)
            // While we have these values in the internal APIs, we can't use it in inlinable code.
            let chachaPolyOverhead = 12 + 16
            
            if (combined.count < chachaPolyOverhead) {
                throw CryptoKitError.incorrectParameterSize
            }
            
            self.combined = Data(combined)
        }
    public init<C, T>(nonce: CryptoKit.ChaChaPoly.Nonce, ciphertext: C, tag: T) throws where C : Foundation.DataProtocol, T : Foundation.DataProtocol
  }
}
extension AES.GCM {
  public struct Nonce : Foundation.ContiguousBytes, Swift.Sequence {
    public init()
    public init<D>(data: D) throws where D : Foundation.DataProtocol
    public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
    public func makeIterator() -> Swift.Array<Swift.UInt8>.Iterator
    public typealias Element = Swift.UInt8
    public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
  }
}
extension ChaChaPoly {
  public struct Nonce : Foundation.ContiguousBytes, Swift.Sequence {
    public init()
    public init<D>(data: D) throws where D : Foundation.DataProtocol
    public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
    public func makeIterator() -> Swift.Array<Swift.UInt8>.Iterator
    public typealias Element = Swift.UInt8
    public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
  }
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum AES {
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SymmetricKeySize {
  public let bitCount: Swift.Int
  public static var bits128: CryptoKit.SymmetricKeySize {
    get
  }
  public static var bits192: CryptoKit.SymmetricKeySize {
    get
  }
  public static var bits256: CryptoKit.SymmetricKeySize {
    get
  }
  public init(bitCount: Swift.Int)
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SymmetricKey : Foundation.ContiguousBytes {
  public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
  public init<D>(data: D) where D : Foundation.ContiguousBytes
  public init(size: CryptoKit.SymmetricKeySize)
  public var bitCount: Swift.Int {
    get
  }
}
extension SymmetricKey : Swift.Equatable {
  public static func == (lhs: CryptoKit.SymmetricKey, rhs: CryptoKit.SymmetricKey) -> Swift.Bool
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public protocol HashFunction {
  @available(iOS 13.2, OSX 10.15, watchOS 6.1, tvOS 13.2, *)
  static var blockByteCount: Swift.Int { get }
  associatedtype Digest : CryptoKit.Digest
  init()
  mutating func update(bufferPointer: Swift.UnsafeRawBufferPointer)
  func finalize() -> Self.Digest
}
extension HashFunction {
  @inlinable internal static func hash(bufferPointer: Swift.UnsafeRawBufferPointer) -> Self.Digest {
        var hasher = Self()
        hasher.update(bufferPointer: bufferPointer)
        return hasher.finalize()
    }
  @inlinable public static func hash<D>(data: D) -> Self.Digest where D : Foundation.DataProtocol {
        var hasher = Self()
        hasher.update(data: data)
        return hasher.finalize()
    }
  @inlinable mutating public func update<D>(data: D) where D : Foundation.DataProtocol {
        data.regions.forEach { (regionData) in
            regionData.withUnsafeBytes({ (dataPtr) in
                self.update(bufferPointer: dataPtr)
            })
        }
    }
}
extension AES {
  public enum GCM {
    public static func seal<Plaintext, AuthenticatedData>(_ message: Plaintext, using key: CryptoKit.SymmetricKey, nonce: CryptoKit.AES.GCM.Nonce? = nil, authenticating authenticatedData: AuthenticatedData) throws -> CryptoKit.AES.GCM.SealedBox where Plaintext : Foundation.DataProtocol, AuthenticatedData : Foundation.DataProtocol
    public static func seal<Plaintext>(_ message: Plaintext, using key: CryptoKit.SymmetricKey, nonce: CryptoKit.AES.GCM.Nonce? = nil) throws -> CryptoKit.AES.GCM.SealedBox where Plaintext : Foundation.DataProtocol
    public static func open<AuthenticatedData>(_ sealedBox: CryptoKit.AES.GCM.SealedBox, using key: CryptoKit.SymmetricKey, authenticating authenticatedData: AuthenticatedData) throws -> Foundation.Data where AuthenticatedData : Foundation.DataProtocol
    public static func open(_ sealedBox: CryptoKit.AES.GCM.SealedBox, using key: CryptoKit.SymmetricKey) throws -> Foundation.Data
  }
}
extension AES.GCM {
  @available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
  public struct SealedBox {
    public var tag: Foundation.Data {
      get
    }
    public var ciphertext: Foundation.Data {
      get
    }
    public var nonce: CryptoKit.AES.GCM.Nonce {
      get
    }
    public var combined: Foundation.Data? {
      get
    }
    @usableFromInline
    internal init(combined: Foundation.Data)
    @inlinable public init<D>(combined: D) throws where D : Foundation.DataProtocol {
            // AES minumum nonce (12 bytes) + AES tag (16 bytes)
            // While we have these values in the internal APIs, we can't use it in inlinable code.
            let aesGCMOverhead = 12 + 16
            
            if (combined.count < aesGCMOverhead) {
                throw CryptoKitError.incorrectParameterSize
            }
            
            self.init(combined: Data(combined))
        }
    public init<C, T>(nonce: CryptoKit.AES.GCM.Nonce, ciphertext: C, tag: T) throws where C : Foundation.DataProtocol, T : Foundation.DataProtocol
  }
}
extension P256.Signing {
  public struct ECDSASignature : Foundation.ContiguousBytes {
    public var rawRepresentation: Foundation.Data
    public init<D>(rawRepresentation: D) throws where D : Foundation.DataProtocol
    public init<D>(derRepresentation: D) throws where D : Foundation.DataProtocol
    public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
    public var derRepresentation: Foundation.Data {
      get
    }
  }
}
extension P256.Signing.PrivateKey {
  public func signature<D>(for digest: D) throws -> CryptoKit.P256.Signing.ECDSASignature where D : CryptoKit.Digest
}
extension P256.Signing.PrivateKey {
  public func signature<D>(for data: D) throws -> CryptoKit.P256.Signing.ECDSASignature where D : Foundation.DataProtocol
}
extension P256.Signing.PublicKey {
  public func isValidSignature<D>(_ signature: CryptoKit.P256.Signing.ECDSASignature, for digest: D) -> Swift.Bool where D : CryptoKit.Digest
}
extension P256.Signing.PublicKey {
  public func isValidSignature<D>(_ signature: CryptoKit.P256.Signing.ECDSASignature, for data: D) -> Swift.Bool where D : Foundation.DataProtocol
}
extension P384.Signing {
  public struct ECDSASignature : Foundation.ContiguousBytes {
    public var rawRepresentation: Foundation.Data
    public init<D>(rawRepresentation: D) throws where D : Foundation.DataProtocol
    public init<D>(derRepresentation: D) throws where D : Foundation.DataProtocol
    public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
    public var derRepresentation: Foundation.Data {
      get
    }
  }
}
extension P384.Signing.PrivateKey {
  public func signature<D>(for digest: D) throws -> CryptoKit.P384.Signing.ECDSASignature where D : CryptoKit.Digest
}
extension P384.Signing.PrivateKey {
  public func signature<D>(for data: D) throws -> CryptoKit.P384.Signing.ECDSASignature where D : Foundation.DataProtocol
}
extension P384.Signing.PublicKey {
  public func isValidSignature<D>(_ signature: CryptoKit.P384.Signing.ECDSASignature, for digest: D) -> Swift.Bool where D : CryptoKit.Digest
}
extension P384.Signing.PublicKey {
  public func isValidSignature<D>(_ signature: CryptoKit.P384.Signing.ECDSASignature, for data: D) -> Swift.Bool where D : Foundation.DataProtocol
}
extension P521.Signing {
  public struct ECDSASignature : Foundation.ContiguousBytes {
    public var rawRepresentation: Foundation.Data
    public init<D>(rawRepresentation: D) throws where D : Foundation.DataProtocol
    public init<D>(derRepresentation: D) throws where D : Foundation.DataProtocol
    public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
    public var derRepresentation: Foundation.Data {
      get
    }
  }
}
extension P521.Signing.PrivateKey {
  public func signature<D>(for digest: D) throws -> CryptoKit.P521.Signing.ECDSASignature where D : CryptoKit.Digest
}
extension P521.Signing.PrivateKey {
  public func signature<D>(for data: D) throws -> CryptoKit.P521.Signing.ECDSASignature where D : Foundation.DataProtocol
}
extension P521.Signing.PublicKey {
  public func isValidSignature<D>(_ signature: CryptoKit.P521.Signing.ECDSASignature, for digest: D) -> Swift.Bool where D : CryptoKit.Digest
}
extension P521.Signing.PublicKey {
  public func isValidSignature<D>(_ signature: CryptoKit.P521.Signing.ECDSASignature, for data: D) -> Swift.Bool where D : Foundation.DataProtocol
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SharedSecret : Foundation.ContiguousBytes {
  public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
  public func x963DerivedSymmetricKey<H, SI>(using hashFunction: H.Type, sharedInfo: SI, outputByteCount: Swift.Int) -> CryptoKit.SymmetricKey where H : CryptoKit.HashFunction, SI : Foundation.DataProtocol
  public func hkdfDerivedSymmetricKey<H, Salt, SI>(using hashFunction: H.Type, salt: Salt, sharedInfo: SI, outputByteCount: Swift.Int) -> CryptoKit.SymmetricKey where H : CryptoKit.HashFunction, Salt : Foundation.DataProtocol, SI : Foundation.DataProtocol
}
extension SharedSecret : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SharedSecret : Swift.CustomStringConvertible, Swift.Equatable {
  public static func == (lhs: CryptoKit.SharedSecret, rhs: CryptoKit.SharedSecret) -> Swift.Bool
  public static func == <D>(lhs: CryptoKit.SharedSecret, rhs: D) -> Swift.Bool where D : Foundation.DataProtocol
  public var description: Swift.String {
    get
  }
}
extension Insecure {
  public struct SHA1 {
    public static var blockByteCount: Swift.Int
    public typealias Digest = CryptoKit.Insecure.SHA1Digest
    public static var byteCount: Swift.Int
    public init()
    mutating public func update(bufferPointer: Swift.UnsafeRawBufferPointer)
    public func finalize() -> CryptoKit.Insecure.SHA1.Digest
  }
  public struct MD5 {
    public static var blockByteCount: Swift.Int
    public typealias Digest = CryptoKit.Insecure.MD5Digest
    public static var byteCount: Swift.Int
    public init()
    mutating public func update(bufferPointer: Swift.UnsafeRawBufferPointer)
    public func finalize() -> CryptoKit.Insecure.MD5.Digest
  }
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public protocol MessageAuthenticationCode : Foundation.ContiguousBytes, Swift.CustomStringConvertible, Swift.Hashable, Swift.Sequence where Self.Element == Swift.UInt8 {
  var byteCount: Swift.Int { get }
}
extension MessageAuthenticationCode {
  public static func == (lhs: Self, rhs: Self) -> Swift.Bool
  public static func == <D>(lhs: Self, rhs: D) -> Swift.Bool where D : Foundation.DataProtocol
  public func makeIterator() -> Swift.Array<Swift.UInt8>.Iterator
  public var description: Swift.String {
    get
  }
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum CryptoKitError : Swift.Error {
  case incorrectKeySize
  case incorrectParameterSize
  case authenticationFailure
  case underlyingCoreCryptoError(error: Swift.Int32)
}
extension Curve25519 {
  public enum KeyAgreement {
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public var rawRepresentation: Foundation.Data {
        get
      }
    }
    public struct PrivateKey {
      public init()
      public var publicKey: CryptoKit.Curve25519.KeyAgreement.PublicKey {
        get
      }
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public func sharedSecretFromKeyAgreement(with publicKeyShare: CryptoKit.Curve25519.KeyAgreement.PublicKey) throws -> CryptoKit.SharedSecret
      public var rawRepresentation: Foundation.Data {
        get
      }
    }
  }
}
extension Curve25519 {
  public enum Signing {
    public struct PrivateKey {
      public init()
      public var publicKey: CryptoKit.Curve25519.Signing.PublicKey {
        get
      }
      public init<D>(rawRepresentation data: D) throws where D : Foundation.ContiguousBytes
      public var rawRepresentation: Foundation.Data {
        get
      }
    }
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public var rawRepresentation: Foundation.Data {
        get
      }
    }
  }
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
extension CryptoKit.SHA256Digest : CryptoKit.Digest {}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
extension CryptoKit.SHA384Digest : CryptoKit.Digest {}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
extension CryptoKit.SHA512Digest : CryptoKit.Digest {}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
extension CryptoKit.Insecure.SHA1Digest : CryptoKit.Digest {}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
extension CryptoKit.Insecure.MD5Digest : CryptoKit.Digest {}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
extension CryptoKit.SHA256 : CryptoKit.HashFunction {}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
extension CryptoKit.SHA384 : CryptoKit.HashFunction {}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
extension CryptoKit.SHA512 : CryptoKit.HashFunction {}
extension CryptoKit.Insecure.SHA1 : CryptoKit.HashFunction {}
extension CryptoKit.Insecure.MD5 : CryptoKit.HashFunction {}
